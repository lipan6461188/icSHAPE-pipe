
#include "sliding_shape.h"
#include "version.h"

#define WARNING "The input tab file must be sorted (generated by sam2tab)"

void print_usage()
{
    char buff[2000];
    const char *help_info = 
            "countRT - count RT and BD\n"
            "=============================================================\n"
            "\e[1mUSAGE:\e[0m\n"
            "\tcountRT -in input1.tab,input2.tab... -size chrSizeFile [-ijf junctionFile] -out outputFile\n"
            "\e[1mHELP:\e[0m\n"
            "\t-in: tab file generated by sam2tab, multiple files seperated by comma \n"
            "\t-size: input a chromosome size file generated by STAR (chrNameLength.txt) \n"
            "\t-ijf: input a junction file generated by STAR (sjdbList.fromGTF.out.tab)\n"
            "\t-ojf: output a junction file with sopported reads\n"
            "\t-omc: minimul DMSO BD for output (default: 50)\n"
            "\t-out: output RT and BD\n\n"

            "\t-genome: genome fasta file, base will be output (default: None)\n\n"

            "\e[1mWARNING:\e[0m\n\t%s\n"
            "\e[1mVERSION:\e[0m\n\t%s\n"
            "\e[1mLIB VERSION:\e[0m\n\t%s\n"
            "\e[1mDATE:\e[0m\n\t%s\n"
            "\e[1mAUTHOR:\e[0m\n\t%s\n";

    ostringstream warning;
    warning << YELLOW << WARNING << DEF;

    sprintf(buff, help_info, warning.str().c_str(), BINVERSION, LIBVERSION, DATE, "Li Pan");
    cout << buff << endl;
}

struct Param
{
    StringArray inputFiles;
    string outputFile;

    string size_file;
    string junction_file;
    string out_junc_file;

    uINT out_min_cov = 50;

    string genome_seq_file;

    operator bool()
    {
        if(inputFiles.size() == 0)
        {
            cerr << RED << "Please specify -in" << DEF << endl;
            return false;
        }
        if(outputFile.empty() or size_file.empty())
        {
            cerr << RED << "Please specify -size -out" << DEF << endl;
            return false;
        }
        return true;
    }
};

void has_next(int argc, int current)
{
    if(current + 1 >= argc)
    {
        cerr << RED << "FATAL ERROR: Parameter Error" << DEF << endl;
        print_usage();
        exit(-1);
    }
}

Param read_param(int argc, char *argv[])
{
    Param param;

    if(argc <= 1)
    {
        print_usage();
        exit(-1);
    }

    for(int i=1; i<argc; i++)
    {
        if( argv[i][0] == '-' )
        {
            if(not strcmp(argv[i]+1, "in"))
            {
                has_next(argc, i);
                split(argv[i+1], ',', param.inputFiles);
                i++;
            }else if(not strcmp(argv[i]+1, "out"))
            {
                has_next(argc, i);
                param.outputFile = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "size"))
            {
                has_next(argc, i);
                param.size_file = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "ijf"))
            {
                has_next(argc, i);
                param.junction_file = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "ojf"))
            {
                has_next(argc, i);
                param.out_junc_file = argv[i+1];
                i++;
            }else if(not strcmp(argv[i]+1, "omc"))
            {
                has_next(argc, i);
                param.out_min_cov = stoul(argv[i+1]);
                i++;
            }else if(not strcmp(argv[i]+1, "genome"))
            {
                has_next(argc, i);
                param.genome_seq_file = argv[i+1];
                i++;
            }else{
                cerr << RED << "FATAL ERROR: unknown option: " << argv[i] << DEF << endl;
                print_usage();
                exit(-1);
            }
        }else{
            cerr << RED << "FATAL ERROR: unknown option: " << argv[i] << DEF << endl;
            print_usage();
            exit(-1);
        }
    }
    return param;
}

void write_RTBD(ofstream &OUT, const string &chr_id_strand, vector<uIntArray> &rt_Array, vector<uIntArray> &bd_Array, const string &chr_seq, const uINT min_D)
{
    const uLONG cSize = bd_Array.front().size() - 1;

    if(rt_Array.size() != bd_Array.size())
    {
        cerr << RED << "FATAL Error: rt_Array and bd_Array different length" << DEF << endl;
        exit(-1);
    }
    if(not chr_seq.empty() and rt_Array.front().size()!=chr_seq.size()+1)
    {
        cerr << RED << "FATAL Error: rt_Array and chr_seq different length " << rt_Array.front().size()-1 << " and " << chr_seq.size() << ". Skip this one" << DEF << endl;
        return;
    }

    string chr_id = chr_id_strand.substr(0, chr_id_strand.size()-1);
    char strand = chr_id_strand.back();


    for(uLONG i=1; i<=cSize; i++)
    {
        string base;
        if(not chr_seq.empty())
            base = base + "\t" + chr_seq[i-1];

        if( any_of(rt_Array.begin(), rt_Array.end(), [&i](uIntArray &a){return a[i]>=1;}) or 
            any_of(bd_Array.begin(), bd_Array.end(), [&i, &min_D](uIntArray &a){return a[i]>=min_D;}) )
        {
            OUT << chr_id << "\t" << strand << "\t" << i << base;
            for(uLONG j=0; j<rt_Array.size(); j++)
            {
                OUT << "\t" << rt_Array[j][i] << "\t" <<  bd_Array[j][i];
            }
            OUT << "\n";
        }
    }
}

bool fetch_chr_seq(qFasta &seq_holder, const string &chrID, const STRAND &strand, string &chr_seq)
{
    if(not seq_holder.has_chr(chrID))
    {
        return false;
    }
    //uLONG chrLen = seq_holder.get_chr_len(chrID);
    chr_seq = seq_holder.get_chr_subbseq(chrID, 0, string::npos, strand);

    if(strand == NEGATIVE)
        reverse(chr_seq.begin(),chr_seq.end());

    return true;
}

string compile_head(const StringArray &inputFiles, bool use_genome)
{
    int colNum = inputFiles.size() * 2 + 3 + use_genome;
    string head = "@ColNum "+to_string(colNum)+"\n@ChrID 1\n@Strand 2\n@ChrPos 3\n";
    if(use_genome)
        head += "@Base 4\n";

    int num = 4;
    if(use_genome)
        num = 5;
    for(string file: inputFiles)
    {   
        StringArray items;
        split(file, '/', items);
        string fn = items.back();
        head += "@RT_"+fn+" "+to_string(num++)+"\n";
        head += "@BD_"+fn+" "+to_string(num++)+"\n";
    }
    return head;
}

int main(int argc, char *argv[])
{

    Param param = read_param(argc, argv);

    if(not param)
    {
        print_usage();
        exit(-1);
    }

    MapStringT<JunctionArray> junctions;
    MapStringuLONG chr_size;

    clog << "load_chr_size..." << endl;
    load_chr_size(param.size_file, chr_size);

    if(param.junction_file.empty())
    {
        cerr << RED << "Waning: no junction file given" << DEF << endl;
    }else{
        clog << "load_junctions..." << endl;
        load_junctions(param.junction_file, junctions, chr_size);
    }

    clog << "Start to init input handles..." << endl;
    vector<ifstream *> i_vec;
    for(string fn: param.inputFiles)
    {
        i_vec.push_back( new ifstream(fn, ifstream::in) );
        check_input_handle(*i_vec.back(), fn);
    }

    StringArray chr_ids(i_vec.size());
    vector< vector<Map_Record> > record_array(i_vec.size());

    string chr_seq;
    bool use_genome = param.genome_seq_file.empty() ? false : true;
    qFasta fasta;
    if(use_genome)
        fasta.load_fasta_file(param.genome_seq_file);

    ofstream OUT(param.outputFile, ofstream::out);

    /*
    if(use_mask)
        OUT << "@ColNum 10\n@ChrID 1\n@Strand 2\n@ChrPos 3\n@Base 4\n@N_RT 5\n@N_BD 6\n@D_RT 7\n@D_BD 8\n@Shape 9\n@ShapeNum 10\n@WindowShape 11\n";
    else
        OUT << "@ColNum 10\n@ChrID 1\n@Strand 2\n@ChrPos 3\n@N_RT 4\n@N_BD 5\n@D_RT 6\n@D_BD 7\n@Shape 8\n@ShapeNum 9\n@WindowShape 10\n";
    */

    OUT << compile_head(param.inputFiles, use_genome);

    uLONG index = 0;
    while(sync_chrs(i_vec, chr_ids, record_array))
    {
        const string chr_id = chr_ids[0];
        if(chr_size.find(chr_id) == chr_size.end())
        {
            cerr << RED << "Warning: " << chr_id << " not found on size file" << DEF << endl;
            continue;
        }

        if(junctions.find(chr_id) == junctions.end())
        {
            cerr << RED << "Warning: " << chr_id << " junction not found" << DEF << endl;
            junctions[chr_id];
        }

        if(junctions[chr_id].size() > 0)
        {
            clog << "Start to build_junction_support" << endl;
            for(vector<Map_Record> &a: record_array)
                build_junction_support(a, junctions.at(chr_id));

            clog << "Start to combine_junction" << endl;
            combine_junction(junctions[chr_id]);

            clog << "Start to check_overlap" << endl;
            check_overlap(junctions[chr_id], chr_size.at(chr_id));
        }

        clog << index++ <<  ". read_chr " << chr_id << "\t" << chr_size.at(chr_id) << endl;

        const uLONG cSize = chr_size.at(chr_id);
        
        vector<uIntArray> rt_array(i_vec.size());
        for(uIntArray &a: rt_array)
            a.assign(cSize+1, 0);
        
        vector<uIntArray> bd_array(i_vec.size());
        for(uIntArray &a: bd_array)
            a.assign(cSize+1, 0);

        const uLONG binsize = 1000000;

        FloatArray score(cSize+1, null);

        if(record_array.front().front().strand == POSITIVE)
        {
            clog << "Start to calc_chr_BDRT_Pos" << endl;
            for(uLONG i=0; i<i_vec.size(); i++)
            {
                uLONG BD_ext = 0;
                calc_chr_BDRT_Pos(bd_array.at(i), rt_array.at(i), record_array.at(i), junctions[chr_id], cSize, BD_ext, binsize);
            }
        }
        else
        {
            clog << "Start to calc_chr_BDRT_Neg" << endl;
            for(uLONG i=0; i<i_vec.size(); i++)
            {
                uLONG BD_ext = 0;
                calc_chr_BDRT_Neg(bd_array.at(i), rt_array.at(i), record_array.at(i), junctions[chr_id], cSize, BD_ext, binsize);
            }
        }

        if(use_genome)
        {
            string true_chr_id = chr_id.substr(0, chr_id.size()-1);
            STRAND s = record_array.front().front().strand;
            bool success = fetch_chr_seq(fasta, true_chr_id, s, chr_seq);
            if(not success)
            {
                cerr << RED << "Warning: " << chr_id << " not found on genome file, skip it" << DEF << endl;
                continue;
            }
        }

        clog << "Start to write_RTBD: " << chr_id << endl;
        write_RTBD(OUT, chr_id, rt_array, bd_array, chr_seq, param.out_min_cov);

        clog << " Finish " << chr_id << endl;
    }

    for(uLONG i=0; i<i_vec.size(); i++)
    {
        i_vec[i]->close();
        delete i_vec[i];
    }

    if(not param.out_junc_file.empty())
    {
        clog << "write_junctions" << endl;
        write_junctions(junctions, param.out_junc_file);
    }
}


